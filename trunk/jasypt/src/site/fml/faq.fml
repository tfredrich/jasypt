<?xml version="1.0" encoding="ISO-8859-1"?>
<faqs title="Frequently Asked Questions">


  <part id="general">
    <title>General</title>
    
    <faq id="what-is-jasypt-useful-for">
      <question>What is jasypt useful for? Give me some examples of use, please...</question>
      <answer>
        <p>
          Jasypt is useful for many encryption tasks associated with applications, for example:
        </p>
        <ul>
          <li>Encrypting passwords.</li>
          <li>Encrypting sensitive information.</li>
          <li>Encrypting data communications.</li>
          <li>Creating sums for integrity checking of data.</li>
          <li>...and many more.</li>
        </ul>
      </answer>
    </faq>
    
    <faq id="does-jasypt-implement-algorithms">
      <question>Does Jasypt implement its own encryption algorihms? Is it "simplified encryption" because it is less safe?</question>
      <answer>
        <p>
          No. Jasypt does not implement any encryption algorithms, but instead
          delegates to the ones already provided by the JCE 
          (Java Cryptography Extension), adding a layer for ease and 
          correctness of use, configurability, integration with many 
          other technologies, etc.
        </p>
        <p>
          If is "simplified encryption" because it is much easier to use
          and integrate than the standard APIs, but you will
          get the same encryption power as if you were using JCE directly, 
          or even more, as jasypt will enforce
          best practices and use standards that will ensure that you always
          get the highest level of security from encryption.
        </p>
      </answer>
    </faq>

    <faq id="i-dont-use-hibernate">
      <question>I don't use Hibernate at all. Can I use jasypt anyway?</question>
      <answer>
        <p>
          Yes, you can. Jasypt provides an <b>optional</b> integration package for
          Hibernate, but <b>it does not need Hibernate for normal operation</b>. It 
          won't add a dependency on Hibernate to your project.
        </p>
      </answer>
    </faq>

    <faq id="i-dont-use-spring">
      <question>I don't use Spring at all. Can I use jasypt anyway?</question>
      <answer>
        <p>
          Yes, you can. Jasypt is designed to be seamlessly integrated into
          a Spring-based application if required, but <b>it does not depend on Spring</b>
          in any way. It won't add a dependency on Spring to your project nor
          will force you to develop in an IoC-friendly manner.
        </p>
      </answer>
    </faq>

    <faq id="i-dont-use-spring-security">
      <question>I don't use Spring Security (Acegi) at all. Can I use jasypt anyway?</question>
      <answer>
        <p>
          Yes, you can. Jasypt provides an <b>optional</b> integration
          package for Spring Security, but <b>it does not need Spring Security
          for normal operation</b>.It 
          won't add a dependency on Spring Security to your project.
        </p>
      </answer>
    </faq>
    
    <faq id="which-is-the-difference">
      <question>Which is the difference between digests and password-based encryption?</question>
      <answer>
        <p>
          Digests are the results of applying <b>cryptographic hash functions</b>
          such as MD5,
          and are a type of <i>one-way encryption</i>. This means that an original
          input cannot be reconstructed from its digest, once it has been
          generated.
        </p>
        <p>
          Password-based encryption is a type of <i>bidirectional encryption</i>, which
          means that encrypted data can be decypted to reconstruct the original
          input. Encryption is done by generating an <i>encryption key</i>, and passing it
          to an <b>encryption algorithm</b> such as DES. This key, in password-based
          encryption, is derived from a password set by the user 
          (usually by a applying a digest algorithm to it).
        </p>
      </answer>
    </faq>
    
    <faq id="where-are-jasypt-hibernate-and-jasypt-spring-security">
      <question>Where have the jasypt-hibernate and jasypt-spring-security modules gone?</question>
      <answer>
        <p>
          Jasypt source trunks were merged in version 1.2, so that everything
          is now in a single module, <tt>jasypt</tt>. This has not affected
          the package structure, and you will find the
          jasypt-hibernate classes in package <tt>org.jasypt.hibernate</tt>
          and the jasypt-spring-security ones at <tt>org.jasypt.springsecurity</tt>,
          as usual.
        </p>
      </answer>
    </faq>
    
  </part>



  <part id="passwords">
    <title>Encrypting paswords</title>

    <faq id="i-am-already-using-X-for-encrypting-passwords">
      <question>I am already using X for encrypting passwords. Why would I want to use jasypt instead?</question>
      <answer>
        <p>
          Well, first of all, if you are simply using a <tt>Message.digest()</tt> 
          or a <tt>DigestUtils.md5()</tt>
          call to encrypt your passwords and store them in a database, you should know
          that your password system is much weaker than you think, and that
          acquiring access to your application could be easy for any attackers.
          And it even becomes worse as the number of users in your application increases.
        </p>
        <p>
          If you want to learn why this happens and how you could try to avoid it,
          have a look at the <a href="encrypting-passwords.html">Encrypting 
          Passwords Guide</a>.
        </p>
        <p>
          ...and, if you are not using such calls but some other APIs or 
          techniques, maybe you should consider reading
          it anyway to know if jasypt can help you do things better.
        </p>
        <p>
          If you are using Spring Security (Acegi Security) for encrypting
          passwords in your application, check the corresponding question in
          this FAQ (below) to see what jasypt can do for you.
        </p>
      </answer>
    </faq>

    <faq id="i-am-already-using-spring-security-for-encrypting-passwords">
      <question>I am already using Spring Security / Acegi for encrypting passwords. Why would I want to add jasypt to my security infrastructure?</question>
      <answer>
        <p>
          Before all, understand that <b>jasypt is not a substitute
          for Spring Security / Acegi</b>, which is a powerful and very complete
          security framework (and which use the Jasypt author truly recommends). 
          Jasypt will instead <b>integrate into Acegi</b>
          and improve its password encoding capabilities.
        </p>
        <p>
          Some reasons for considering this integration are:
        </p>
        <ul>
          <li>First and most important, because the default standard encryptors (<tt>PasswordEncoder</tt>
          implementations) shipped with Acegi (as of 1.0.4) are simple
          message digesters (one hashing iteration, none or user-property based fixed salt...), 
          and are not as safe as
          jasypt's password encryptors can be (learn more about random salt and
          iteration count at the <a href="encrypting-passwords.html">Encrypting 
          Passwords Guide</a>).</li>
          <li>Second, because they don't provide the same level of configuration
          capabilities as jasypt's password encryptors: algorithms, 
          parameters resolution...</li>
          <li>And third, because using jasypt will help you decoupling your
          user management logic (more bussiness-oriented) from the authentication
          and authorization component represented by Acegi (you won't
          need to add dependencies on Acegi's <tt>PasswordEncoder</tt>s to
          your user management logic, and will instead use classes from a more
          neutral library like jasypt).</li>
        </ul>
        <p>
          For more information on integrating Jasypt into an Acegi-enabled
          application, please check the <a href="springsecurity.html">Jasypt + Acegi</a> guide.
        </p>
      </answer>
    </faq>
    
    <faq id="i-want-to-encrypt-a-password">
      <question>I want to encrypt passwords and I know NOTHING about encryption. What do I have to do?</question>
      <answer>
        <p>
          Simply use <a href="api/jasypt/apidocs/org/jasypt/util/password/BasicPasswordEncryptor.html">org.jasypt.util.password.BasicPasswordEncryptor</a>.
          There is nothing more you need to know (if you don't want to :-)).
        </p>
        <p>
          If you want more power (such as deciding which algorithm to use),
          then you can have a look at <a href="api/jasypt/apidocs/org/jasypt/digest/StandardStringDigester.html">org.jasypt.digest.StandardStringDigester</a>.
        </p>
        <p>
          And if you want to know more, have a look at
          the <a href="encrypting-passwords.html">Encrypting Passwords</a>
          guide to learn about how a password should be encrypted.
        </p>
      </answer>
    </faq>
    
    <faq id="can-i-decrypt-an-encrypted-password">
      <question>Can I decrypt an encrypted password?</question>
      <answer>
        <p>
          If you have encrypted it using a message digesting technique, 
          which is precisely what you should have done (by using 
          a <tt>PasswordEncryptor</tt> implementation, 
          <tt>StandardStringDigester</tt> or similar...), <b>you cannot</b>.
        </p>
        <p>
          This is because digests are a <i>one-way</i> technique. Once you have
          created the digest, there is no way to reconstruct the original message
          (or password) back. To check if an input password matches a stored digest, 
          the password is digested itself and then both digests are matched.
        </p>
        <p>
          And why should passwords be encrypted in a way they cannot be decrypted?
          Because this is safest way to ensure that a password is known only
          to the user that created it, and that <i>no one, not even system or database 
          administrators, can know it</i>.
        </p>
      </answer>
    </faq>
    
    
  </part>


  <part id="behaviour">
    <title>Behaviour</title>
    
    <faq id="what-does-jasypt-do-to-create-password-digests">
      <question>What does jasypt do to create message/password digests, exactly? They are so different to the ones I create manually with a MessageDigest object...</question>
      <answer>
        <p>
          Jasypt follows the RSA standards for the creation of digests 
          (in fact, keys), specifically the use of <b>both a 
          (preferably random) salt and
          an iteration count</b>.
        </p>
        <p>
          The salt is an array of bytes (randomly and securely generated by default) which
          is added to the message prior to digest. The iteration count specifies
          how many times the hash function will be applied to the message.
        </p>
        <p>
          This means that the process of digesting your passwords (or any other 
          messages) with jasypt 
          is not as simple (internally speaking) as just using 
          MessageDigest, and because of this results look quite different.
        </p>
        <p>
          For learning more about how password/message digesting works in jasypt, see
          <a href="encrypting-passwords.html">Encrypting Passwords</a> or the
          <a href="api/jasypt/apidocs/org/jasypt/digest/StandardStringDigester.html">javadoc for StandardStringDigester</a>.
        </p>
        <p>
          For more info about the RSA standard, see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2127">PKCS #5: Password-Based Cryptography Standard</a>.
        </p>
      </answer>
    </faq>
    
    <faq id="if-i-create-two-digests-of-the-same-message">
      <question>If I create two digests of the same message (or I encrypt the same password twice), results differ. Is that normal?</question>
      <answer>
        <p>
          If you are using a random salt generator (which is the default), 
          yes, it is. It is normal and, specially if you are
          encrypting a password, it is good for you.
        </p>
        <p>
          Using a random salt offers you several important security advantages
          as you can read in <a href="encrypting-passwords.html">Encrypting Passwords</a>,
          but if it is important for you that two digests of the same message
          be equal, you can set the salt size to 0 bytes or, if you
          prefer, use a different implementation of 
          <a href="api/jasypt/apidocs/org/jasypt/salt/SaltGenerator.html">SaltGenerator</a>.
        </p>
        <p>
          A salt is also used for the obtention
          of keys for password-based encryption and so, when using a random 
          salt generator (default), two password-based encryption
          results for the same original input will also differ. Nevertheless, 
          this behaviour cannot be avoided in password-based encryption by setting
          a zero-byte long salt, as
          a salt is required by the PBE Java API itself. Thus, in this case
          you will have to use a fixed-salt <i>SaltGenerator</i>.
        </p>
      </answer>
    </faq>
    <faq id="I-see-jasypt-uses-salt-and-iteration-count">
      <question>I see jasypt uses salt and iteration count for creating digests. Does it also use them for generating keys for password-based encryption?</question>
      <answer>
        <p>
          Of course. You see the use of salt and iteration count 
          more thoroughly explained in jasypt documentation when referred to
          digests, but this is simply because many people wrongly (and dangerously) forget about 
          using them when
          doing digests of, say, passwords. Thus, it seemed important to remark
          its use when digesting.
        </p>
        <p>
          On the contrary, password-based encryption is usually done the right way, partly
          because the Java API for PBE enforces it to some extent. Anyway,
          jasypt offers you the advantage of transparently dealing with secure 
          salt generation and checking.
        </p>
        <p>
          For more info about the way password-based encryption should be done
          (and is done by jasypt), see see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2127">PKCS #5: Password-Based Cryptography Standard</a>.
        </p>
      </answer>
    </faq>
    <faq id="why-only-big-numbers">
      <question>Why does jasypt number encryption support only apply to <tt>BigInteger</tt> and <tt>BigDecimal</tt>?</question>
      <answer>
        <p>
          Because numbers are encrypted using the byte encryption support
          (encryption algorithms refer to bytes, not numbers), and so the
          result of encrypting a number will span a higher number of bytes than
          the original number. This provokes that a 4-byte integer needs no less
          than 16 bytes when it is in encrypted form.
        </p>
        <p>
          Because of this, only <tt>BigInteger</tt>s and <tt>BigDecimal</tt>s
          are supported in jasypt, as they provide arbitrary precision and
          so can handle such a big amount of bytes.
        </p>
        <p>
          Nevertheless, if you are looking for hibernate encryption support
          for Longs, Doubles, Integers... jasypt provides support for encrypting
          them stored into SQL VARCHAR fields (instead of NUMERIC ones).
          Have a look at the <a href="hibernate3.html">Hibernate Integration
          Guide</a> for further details.
        </p>
      </answer>
    </faq>
    
  </part>  


  <part id="problems">
    <title>Problems</title>

    <faq id="encrypted-fields-not-in-where">
      <question>I do not get correct results when querying a Hibernate-mapped entity with encrypted fields when I set conditions on some of those fields.</question>
      <answer>
        <p>
          This is normal behaviour if you are using a random salt generator for your encryptor (which is the default). 
          In this case, two different encryption operations on the same data should not 
          return the same
          value (due to the use of a random salt). Because of this, none of the fields that
          are set to be encrypted when persisted can be a part of a WHERE clause in
          your search queries for the entity they belong to.
        </p>
        <p>
          If you need to query encrypted fields, <b>you should set a fixed 
          salt generator</b> to your encryptor, so that the same text encrypted
          twice will produce the same results. Although, be warned that <i>this
          will only allow you to use that field in EQUALITY comparisons inside
          a WHERE clause, and that you will be reducing your level of security
          for that field</i>.
        </p>
      </answer>
    </faq>
   
    <faq id="no-unlimited-strength">
      <question>I receive an <tt>InvalidKeyException</tt> when trying to use the <tt>StrongTextEncryptor</tt> or the <tt>PBEWithMD5AndTripleDES</tt> algorithm, but other algorithms work alright.</question>
      <answer>
        <p>
          This probably happens because you need download and install the
          <a href="http://java.sun.com/javase/downloads" target="_blank">Java 
          Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy 
          Files</a> in order to be able to use strong-encryption algorithms like TripleDES.
        </p>
      </answer>
    </faq>
    
  </part>


  
</faqs>