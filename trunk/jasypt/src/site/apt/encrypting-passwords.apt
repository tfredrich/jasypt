
Encrypting passwords

  This guide is about encrypting passwords the correct way, and
  why you should consider using jasypt for encrypting passwords in your 
  applications. For the correct understanding of this text, you should have 
  an idea of 
  what a <<message digest>> is and its applications to password encryption.
  {{{http://en.wikipedia.org/wiki/Message_digest}Learn More [wikipedia.org]}}.

=============

  Today, most applications (specially web applications) use some message digesting
  technique for encrypting user passwords. This is just one of the uses
  of message digesting but, by far, it is the most popular.
  
  There are several possibilities for implementing this, some of the most common are:
  
      * Using <<java.security.MessageDigest>> directly.
      
      []
      
      * Using commons-codec's <<org.apache.commons.codec.digest.DigestUtils>>.
      
      []
      
      * ...using some other digest utilities or MessageDigest wrappers.
      
  Having so many possibilities, <<why would we want to use jasypt?>> Well, because
  <none of these techniques completely implements what is stated in the
  RSA standard for the creation of digests (in fact, encryption keys) in
  {{{http://www.rsasecurity.com/rsalabs/node.asp?id=2127}PKCS #5: Password-Based Cryptography Standard}}>.
  
  When digesting passwords, you should:
  
      * <<Use a (preferably random) salt>> with a size of at least 8 bytes which
        you should append to your message before digesting, and then again
        after digesting (so that you can later be able to know which the
        salt was).
        
      []
        
      * Apply <<hashing iteration>>, this is, apply the hashing function
        iteratively to its own results a number of times (at least 1000,
        according to the standard).
  
  And this is precisely what jasypt does for you.
  
  
* Digest creation process with jasypt's Standard\[Byte\|String\]Digester

  <[The techniques seen here also apply to the provided implementations of org.jasypt.util.password.PasswordEncryptor]>

  The steps taken in jasypt's standard digesters for creating digests are:
  
    [[1]]A salt of the specified size is generated (see 
        <<org.jasypt.salt.SaltGenerator>>). If salt size is zero, no salt will be
        used. It is advisable that you use a random salt generator like 
        <<org.jasypt.salt.RandomSaltGenerator>> (which is the default) for 
        higher security.
        
    [[2]]The salt bytes are appended at the beginning of the message.
    
    [[3]]The hash function is applied to the salt and message altogether, 
        and then to the
        results of the function itself, as many times as specified
        (iterations).
        
    [[4]]If using a random salt generator, the <undigested> salt is appended 
        at the beginning of the hash result.
  
  Put schematically in bytes:
  
    *  DIGEST  =  \|<<S>>\|..(ssb)..\|<<S>>\|<<X>>\|<<X>>\|<<X>>\|...\|<<X>>\|
    
          * <<S>>: salt bytes (plain, not digested). <(Only if using a random salt generator)>.
          
          * ssb: salt size in bytes.
          
          * <<X>>: bytes resulting from hashing (see below).

    []
          
    *  |<<X>>|<<X>>|<<X>>|...|<<X>>|  =  <H>(<H>(<H>(..(it)..<H>(<<Z>>|<<Z>>|<<Z>>|...|<<Z>>|))))
    
          * <H>: Hash function (algorithm).
          
          * it: Number of iterations.
          
          * <<Z>>: Input for hashing (see below).
      
    [] 
       
    *  |<<Z>>|<<Z>>|<<Z>>|...|<<Z>>|  =  |<<S>>|..(ssb)..|<<S>>|<<M>>|<<M>>|<<M>>...|<<M>>|
    
          * <<S>>: salt bytes (plain, not digested).
          
          * ssb: salt size in bytes.
          
          * <<M>>: message bytes.
         
  <<When using a random salt generator, two digests created for the same 
  message will always be different
  (except in the case of random salt coincidence or no usage of salt).>>
  Because of this, in this case the result of the <<<digest>>> method will contains
  both the <undigested> salt and the digest of salt+message, 
  so that another digest operation can be performed with the same salt 
  on a different message to check if both messages match (all of which will 
  be managed automatically by the <<<matches>>> method).

  Also, when using StandardStringDigester, the resulting digest Strings are BASE64
  encoded to avoid charset issues.
  

* Preventing attacks with salt and hashing iteration

  <Ok, all of this is alright, it is more secure to use salt and iterations,
  but... why? What is the real difference?>
  
  Well... if you mind about your users' passwords (which you really 
  should), you MUST use them. This is why:
 
  
** Brute force attacks

  <<Performed on>>: A single user password.
  
  <<Description>>: The attacker tries to get the user's password by exhaustively
  generating all possible passwords, digesting them and testing if they match with the user's password digest.
  {{{http://en.wikipedia.org/wiki/Brute_force_attack} Learn more [wikipedia.org]}}.

  <<Advantages of digesting correctly>>: By iterating the hash function 
  to a number like 1000 (minimum recommended), the overhead of password
  digest creation for the user at sign-up or sign-in time is not significant,
  but the accumulated cost for a brute force attacker generating millions of
  digests will be very considerable. Remember that the best way to protect your
  encrypted data is making the cost of breaking your security too high to
  be worth the effort.

  
** Dictionary attacks

  <<Performed on>>: A single user password or a complete set of user passwords.
  
  <<Description>>: The attacker tries to get the user's password by matching
  its digest against a set of "most possible" password digests, typically generated from
  a list of words in a dictionary. This attack exploits a severe weakness in nowadays applications, as an important
  amount of users set a dictionary word as their password.
  {{{http://en.wikipedia.org/wiki/Dictionary_attack} Learn more [wikipedia.org]}}.
  
  <<Advantages of digesting correctly>>: By adding a random salt, the 
  weakness of the dictionary-based passwords many people use is reduced
  (they no longer are dictionary words),
  and the possibility of the digest appearing on a set of digests previously
  created by the attacker is minimal.

  
** Birthday attacks

  <<Performed on>>: Complete sets of user passwords.

  <<Description>>: This attack exploits the {{{http://en.wikipedia.org/wiki/Birthday_paradox}Birthday paradox [wikipedia.org]}}, which in brief
  states that, having a large set of user password digests, the possibilities of
  generating a password which digest <collides> with at least one of the digests in
  the set is very much higher than what you would intuitively expect. And this
  possibilities increase dramatically as the size of the set (the number of
  users) augments.
  {{{http://en.wikipedia.org/wiki/Birthday_attack} Learn more [wikipedia.org]}}.
  
  <<Advantages of digesting correctly>>: By adding a random salt the 
  possibilities of a birthday attack to succeed are minimum, because the 
  attacker would have to attack each password separately, and not the set of 
  passwords as a whole, to find a collision. This is because he/she would have 
  to find a password that creates the same digest as the attacked one <using 
  the same salt which was used for digesting it>, which is different for each 
  password (this is, it would become a brute force attack).  
  